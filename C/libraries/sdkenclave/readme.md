# SDK ENCLAVE

This is the version 2 of the loader that relies on the `tyche` driver.
The loader parses the enclave binary and generates the corresponding page tables.
It then performs an `mmap` call to the driver to allocate the necessary physical memory.
The enclave layout in physical memory is as follows:

````
| ---------- segment 1 ---------- | phys: X
| ---------- segment 2 ---------- | phys: X + align(size(segment 1))
...
| ------------ cr3 -------------- | phys: sum[align(size(segment i) for i in segments] == cr3_addr
| ---------- page entry---------- | phys: cr3_addr + 0x1000
...

````

The page tables are generated when the value of X, the physical offset, is unknown and thus set to 0.
The `fix_page_tables` function get the X value from the driver once physical memory is allocated.
The segments are copied starting with segment 1 at X, etc.
The page table entries are then patched by adding X to all the non-empty entries.

## Building applications

We are trying to automate as much as possible.
The `runtime` folder contains a definition for the enclave stack and a default shared buffer.
Any section whose name starts with `.tyche_shared` will be mapped by the loader as shared memory. 

The library expects the enclave to define an entry point:

````
extern void trusted_entry(frame_t* frame); 
````

The library further overwrites the `_start` function as we do not expect (for the moment) any libc.
If you want the default shared buffer to be generated by the binary, you should use the `-DDEFAULT_SHARED_BUFFER=1`.

## Legacy loader

The legacy loader, `loader/lib.c`, relies on the fact that the enclave should include the runtime/lib.c code and thus have two default sections, one for the enclave's stack and another for the enclave's shared buffer with the untrusted world.

The legacy loader create a `bump` object inside the enclave's configuration to generate page tables contiguous to the enclave's memory segments.

## Tychools-based loader

As efforts were invested into providing offline instrumentation of binaries with Tychools, we created another loading path that skips the legacy loader's parsing of sections and generation of page tables, as these are both included as segments directly in the instrumented binary.

The tychools loader relies on the segment's type to determine how a segment must be loaded, i.e., on the specific LOOS (OS-specific segment type) to know if a segment is kernel/user confidential/share/stack or page tables.

This simplifies the loader's logic by a lot.

## SDK-APP

In order to allow both legacy and tychools app to run with the same loader, we create the `sdk_app` function.
For the moment, legacy mode is on by default.
The sdk gives knobs as environment variable to tell the loader how to load the enclave.

`ENCL_INCL`: if this variable is defined in the environment, the sdk_app create enclave functions knows that the ELF binary for the enclave is included, as a section, in the untrusted binary's ELF.
It thus opens and parses itself to extract the enclave.

`ENCL_BIN`: if specified, this variable allows to rename the enclave to be loaded. 
This can be used to load different enclave with the same untrusted code or to give a non-conflicting name to an enclave ELF being extracted from the current untrusted binary (e.g., when ENCL_INCL=1).
If not specified, the default name for the enclave is `enclave` and is expected to be found in the same folder as the untrusted app.

`TYCHOOLS`: This variable specifies the loader to be used. If the variable exists, the tychools loader is used and no extra memory regions are created. This leads to `enclave.config.loader_type = TYCHOOL_LOADER`.
If not, the legacy loader is used and `enclave.config.loader_type = LEGACY_LOADER` and the loader will look for shared and stack sections instead of segments.

## Runtime

The runtime of the enclave in `runtime/lib.c` supports both tychools and legacy binaries.
The default is legacy mode, that creates two sections (one for the shared memory, one for the enclave's stack).
To enable tychool loader, specify `-DTYCHOOLS=1` as part of the compilation arguments.
By default, it casts a shared_buffer pointer to the address `0x300000` which should map the enclave's instrumentation done by tychools (make sure you add a shared segment at that address).  
TODO: we will find a more flexible way later.
