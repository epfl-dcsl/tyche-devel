diff --git a/modules/libraries/enclave/src/ioctl.c b/modules/libraries/enclave/src/ioctl.c
index a634f93..c21e33d 100644
--- a/modules/libraries/enclave/src/ioctl.c
+++ b/modules/libraries/enclave/src/ioctl.c
@@ -40,6 +40,8 @@ static struct file_operations fops =
 
 // ———————————————————————————— Driver Functions ———————————————————————————— //
 
+extern void tc_print_alloc_stats(void);
+
 int tyche_enclave_register(void)
 {
   // Allocating Major number
@@ -117,16 +119,18 @@ long tyche_enclave_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
       debugging_transition(arg);
       break;
     case TYCHE_TRANSITION:
-      if(switch_enclave((tyche_encl_handle_t) arg) != 0) {
+      tc_print_alloc_stats();
+      /*if(switch_enclave((tyche_encl_handle_t) arg) != 0) {
         pr_err("[TE]: error enclave_transition.\n");
         return FAILURE;
-      }
+      }*/
       break;
     case TYCHE_ENCLAVE_DELETE:
       if (delete_enclave((tyche_encl_handle_t) arg) != 0) {
         pr_err("[TE]: delete_enclave failed!\n");
         return FAILURE;
       }
+      tc_print_alloc_stats();
       break;
     case TYCHE_ENCLAVE_CREATE:
       // TODO replace this with a tyche vmcall that yields an address
@@ -145,6 +149,8 @@ long tyche_enclave_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
         pr_err("[TE]: Error copying handle to user space.\n");
         return FAILURE;
       }
+      // Print the information
+      tc_print_alloc_stats();
       break;
     case TYCHE_ENCLAVE_ADD_REGION:
       //TODO THIS IS DANGEROUS AS IT ALLOWS TO WRITE ON A STACK VARIABLE
diff --git a/modules/libraries/tyche-capabilities/src/driver.c b/modules/libraries/tyche-capabilities/src/driver.c
index 85d3599..39d2b35 100644
--- a/modules/libraries/tyche-capabilities/src/driver.c
+++ b/modules/libraries/tyche-capabilities/src/driver.c
@@ -12,19 +12,24 @@ MODULE_VERSION("0.01");
 
 // ———————————————————————————————— Helpers ————————————————————————————————— //
 
+// TODO for debugging, remove later.
+static unsigned long long counter_alloc = 0;
+
 static void* local_allocator(unsigned long size)
 {
+  counter_alloc++;
   return kmalloc(size, GFP_KERNEL);
 }
 
 static void local_free(void* ptr)
 {
+  counter_alloc--;
   kfree(ptr);
 }
 
 static void local_print(const char *msg)
 {
-  printk(KERN_ERR "[CAPA]: %s",msg);
+  printk(KERN_ERR "[CAPA | %lld]: %s",counter_alloc, msg);
 }
 
 // —————————————————————— Loading/Unloading  functions —————————————————————— //
@@ -73,6 +78,11 @@ int tc_revoke_domain(domain_id_t id)
   return revoke_domain(id);
 }
 
+void tc_print_alloc_stats(void)
+{
+  printk(KERN_ERR "[CAPA] number of allocs %lld\n", counter_alloc);
+}
+
 // ————————————————————————— Module's Registration —————————————————————————— //
 
 module_init(tyche_capabilities_init);
@@ -84,3 +94,4 @@ EXPORT_SYMBOL(tc_share_region);
 EXPORT_SYMBOL(tc_revoke_region);
 EXPORT_SYMBOL(tc_switch_domain);
 EXPORT_SYMBOL(tc_revoke_domain);
+EXPORT_SYMBOL(tc_print_alloc_stats);
diff --git a/programs/libs/capabilities/src/lib.c b/programs/libs/capabilities/src/lib.c
index e5576cd..563f2ce 100644
--- a/programs/libs/capabilities/src/lib.c
+++ b/programs/libs/capabilities/src/lib.c
@@ -439,6 +439,7 @@ int grant_region(domain_id_t id, paddr_t start, paddr_t end, memory_access_right
       s = capa->access.region.start;
       m = end;
       e = capa->access.region.end;
+      local_domain.print("[DBG] About to grant the left");
       to_grant = &left;
     } else {
       // Right case.
@@ -449,6 +450,7 @@ int grant_region(domain_id_t id, paddr_t start, paddr_t end, memory_access_right
       s = capa->access.region.start;
       m = start;
       e = capa->access.region.end;
+      local_domain.print("[DBG] About to grant the right");
       to_grant = &right;
     }
 
@@ -598,12 +600,18 @@ int internal_revoke(child_domain_t* child, capability_t* capa)
   dll_add(&(local_domain.capabilities), capa, list);
 
   // Check if we can merge it back, this should be the right of the tree.
-  if (capa->parent != NULL && capa->parent->right == capa &&
-      capa->parent->left != NULL && capa->parent->left->capa_type == Resource) {
+  if (capa->parent != NULL && 
+     ((capa->parent->right == capa &&
+        capa->parent->left != NULL && 
+        capa->parent->left->capa_type == Resource) ||
+     (capa->parent->left == capa && 
+      capa->parent->right != NULL &&
+      capa->parent->right->capa_type == Resource))) {
     capability_t *parent = capa->parent;
     if (tyche_revoke(capa->parent->local_id) != SUCCESS) {
       goto failure;
     }
+    local_domain.print("[DBG] Inside the if");
     dll_remove(&(local_domain.capabilities), capa, list);
     dll_remove(&(local_domain.capabilities), (parent->left), list);
     local_domain.dealloc(parent->left);
@@ -614,6 +622,23 @@ int internal_revoke(child_domain_t* child, capability_t* capa)
       local_domain.print("Error[internal_revoke]: unable to enumerate after the merge.");
       goto failure;
     }
+  } else if (capa->parent == NULL) {
+    local_domain.print("[DBG] Parent is null");
+  } else if (capa->parent != NULL && capa->parent->left == NULL) {
+    local_domain.print("[DBG]parent left is null");
+  } else if (capa->parent != NULL && capa->parent->left != NULL && capa->parent->left->capa_type != Resource) {
+    local_domain.print("[DBG] parent left is not null but is not a resource.");
+  } else if (capa->parent != NULL && capa->parent->left == capa) {
+    local_domain.print("[DBG] we are the left");
+    if (capa->parent->right == NULL) {
+      local_domain.print("[DBG] but the right is null");
+    } else if (capa->parent->right->capa_type != Resource) {
+      local_domain.print("[DBG] but the right is not a resource?");
+    }
+  } else if (capa->parent != NULL && capa->parent->right == capa) {
+    local_domain.print("[DBG] we are the right.");
+  } else {
+    local_domain.print("[DBG] no clue what's going on");
   }
 
   // All done!
@@ -654,9 +679,13 @@ int revoke_region(domain_id_t id, paddr_t start, paddr_t end)
     local_domain.print("Error[revoke_region]: unable to find region to revoke.");
     goto failure;
   }
+  if (internal_revoke(child, capa) != SUCCESS) {
+    goto failure;
+  }
   local_domain.print("[revoke_region] success");
-  return internal_revoke(child, capa);
+  return SUCCESS;
 failure:
+  local_domain.print("[revoke_region] failure");
   return FAILURE;
 }
 
